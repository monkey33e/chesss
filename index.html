<!DOCTYPE html>
<html lang="ko">
<head>
    <meta name="google-adsense-account" content="ca-pub-1748676401736913">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì²´ìŠ¤ vs AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 30px;
            max-width: 600px;
            width: 100%;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .game-title {
            font-size: 2.5rem;
            color: #333;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .game-status {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 20px;
        }

        .chessboard {
            width: 480px;
            height: 480px;
            margin: 0 auto;
            border: 3px solid #8B4513;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .square.light {
            background-color: #f0d9b5;
        }

        .square.dark {
            background-color: #b58863;
        }

        .square.selected {
            background-color: #7fb069 !important;
            box-shadow: inset 0 0 0 3px #5a8a4a;
        }

        .square.possible-move {
            background-color: #ffeb3b !important;
            opacity: 0.8;
        }

        .square.last-move {
            background-color: #81c784 !important;
        }

        .square.check {
            background-color: #ff5722 !important;
            animation: checkPulse 1s infinite;
        }

        @keyframes checkPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .square:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }

        .promotion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .promotion-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .promotion-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: #333;
        }

        .promotion-pieces {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .promotion-piece {
            font-size: 3rem;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: white;
        }

        .promotion-piece:hover {
            background: #f0f0f0;
            transform: scale(1.1);
            border-color: #667eea;
        }

        .piece {
            user-select: none;
            transition: transform 0.2s ease;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .difficulty-section {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .difficulty-label {
            font-weight: bold;
            color: #333;
            margin-right: 10px;
        }

        .difficulty-btn {
            padding: 8px 16px;
            border: 2px solid #ddd;
            border-radius: 20px;
            background: white;
            color: #666;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            font-weight: bold;
        }

        .difficulty-btn.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-color: #667eea;
        }

        .difficulty-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.2);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #f5f5f5;
            color: #333;
            border: 2px solid #ddd;
        }

        .btn-secondary:hover {
            background: #e0e0e0;
            transform: translateY(-2px);
        }

        .thinking {
            text-align: center;
            margin-top: 20px;
            font-style: italic;
            color: #666;
        }

        @media (max-width: 600px) {
            .chessboard {
                width: 320px;
                height: 320px;
            }
            
            .square {
                font-size: 1.8rem;
            }
            
            .game-title {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1 class="game-title">â™” ì²´ìŠ¤ vs AI â™›</h1>
            <div class="game-status" id="gameStatus">ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤ (ë°±)</div>
        </div>
        
        <div class="chessboard" id="chessboard"></div>
        
        <div class="controls">
            <button class="btn btn-primary" onclick="newGame()">ìƒˆ ê²Œì„</button>
            <button class="btn btn-secondary" onclick="undoMove()">ë¬´ë¥´ê¸°</button>
        </div>

        <div class="difficulty-section">
            <span class="difficulty-label">ë‚œì´ë„:</span>
            <button class="difficulty-btn" onclick="setDifficulty(1)">1</button>
            <button class="difficulty-btn" onclick="setDifficulty(2)">2</button>
            <button class="difficulty-btn active" onclick="setDifficulty(3)">3</button>
            <button class="difficulty-btn" onclick="setDifficulty(4)">4</button>
            <button class="difficulty-btn" onclick="setDifficulty(5)">5</button>
            <button class="difficulty-btn" onclick="setDifficulty(6)" style="background: linear-gradient(45deg, #ff6b6b, #ee5a24); color: white; border-color: #ff6b6b;">6 ğŸ‘¹</button>
        </div>
        
        <div class="thinking" id="thinking" style="display: none;">
            AIê°€ ìƒê° ì¤‘ì…ë‹ˆë‹¤... ğŸ¤”
        </div>
    </div>

    <!-- í”„ë¡œëª¨ì…˜ ëª¨ë‹¬ -->
    <div class="promotion-modal" id="promotionModal" style="display: none;">
        <div class="promotion-content">
            <div class="promotion-title">í°ì„ ìŠ¹ê¸‰ì‹œí‚¬ ë§ì„ ì„ íƒí•˜ì„¸ìš”</div>
            <div class="promotion-pieces">
                <div class="promotion-piece" onclick="selectPromotion('queen')">â™•</div>
                <div class="promotion-piece" onclick="selectPromotion('rook')">â™–</div>
                <div class="promotion-piece" onclick="selectPromotion('bishop')">â™—</div>
                <div class="promotion-piece" onclick="selectPromotion('knight')">â™˜</div>
            </div>
        </div>
    </div>

    <script>
        // ì²´ìŠ¤ ê²Œì„ ìƒíƒœ
        let board = [];
        let selectedSquare = null;
        let currentPlayer = 'white';
        let gameHistory = [];
        let isGameOver = false;
        let aiDifficulty = 3;
        let enPassantTarget = null; // ì•™íŒŒìƒ ëŒ€ìƒ ìœ„ì¹˜
        let pendingPromotion = null; // ëŒ€ê¸° ì¤‘ì¸ í”„ë¡œëª¨ì…˜
        let isInCheck = { white: false, black: false };

        // ì†Œë¦¬ íš¨ê³¼ ìƒì„±
        function createSound(frequency, duration, type = 'sine') {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // ì´ë™ ì†Œë¦¬
        function playMoveSound() {
            createSound(800, 0.1);
        }

        // ë§ ì¡ëŠ” ì†Œë¦¬
        function playCaptureSound() {
            createSound(400, 0.2, 'square');
            setTimeout(() => createSound(300, 0.15, 'square'), 100);
        }

        // ì²´í¬ë©”ì´íŠ¸ íš¨ê³¼ìŒ
        function playCheckmateSound() {
            // ìŠ¹ë¦¬ íŒ¡íŒŒë ˆ íš¨ê³¼
            const notes = [523, 659, 784, 1047]; // C, E, G, C (í•œ ì˜¥íƒ€ë¸Œ ìœ„)
            notes.forEach((freq, index) => {
                setTimeout(() => {
                    createSound(freq, 0.3, 'sine');
                    // í™”ìŒ ì¶”ê°€
                    setTimeout(() => createSound(freq * 1.25, 0.25, 'sine'), 50);
                }, index * 200);
            });
            
            // ë§ˆì§€ë§‰ì— ê¸´ ìŠ¹ë¦¬ìŒ
            setTimeout(() => {
                createSound(1047, 0.8, 'sine');
                setTimeout(() => createSound(1319, 0.6, 'sine'), 100);
            }, 800);
        }

        // ì²´ìŠ¤ ë§ ìœ ë‹ˆì½”ë“œ
        const pieces = {
            white: {
                king: 'â™”', queen: 'â™•', rook: 'â™–', 
                bishop: 'â™—', knight: 'â™˜', pawn: 'â™™'
            },
            black: {
                king: 'â™š', queen: 'â™›', rook: 'â™œ', 
                bishop: 'â™', knight: 'â™', pawn: 'â™Ÿ'
            }
        };

        // ì´ˆê¸° ë³´ë“œ ì„¤ì •
        function initializeBoard() {
            board = [
                ['â™œ','â™','â™','â™›','â™š','â™','â™','â™œ'],
                ['â™Ÿ','â™Ÿ','â™Ÿ','â™Ÿ','â™Ÿ','â™Ÿ','â™Ÿ','â™Ÿ'],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                [null,null,null,null,null,null,null,null],
                ['â™™','â™™','â™™','â™™','â™™','â™™','â™™','â™™'],
                ['â™–','â™˜','â™—','â™•','â™”','â™—','â™˜','â™–']
            ];
        }

        // ë³´ë“œ ë Œë”ë§
        function renderBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';

            // ì²´í¬ ìƒíƒœ í™•ì¸
            checkForCheck();

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    // ì²´í¬ ìƒíƒœì¸ í‚¹ í•˜ì´ë¼ì´íŠ¸
                    const piece = board[row][col];
                    if (piece === 'â™”' && isInCheck.white) {
                        square.classList.add('check');
                    } else if (piece === 'â™š' && isInCheck.black) {
                        square.classList.add('check');
                    }
                    
                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.className = 'piece';
                        pieceElement.textContent = piece;
                        square.appendChild(pieceElement);
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    chessboard.appendChild(square);
                }
            }
        }

        // ë§ì˜ ìƒ‰ê¹” í™•ì¸
        function getPieceColor(piece) {
            if (!piece) return null;
            return 'â™”â™•â™–â™—â™˜â™™'.includes(piece) ? 'white' : 'black';
        }

        // ìœ íš¨í•œ ì´ë™ì¸ì§€ í™•ì¸
        function isValidMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            if (!piece) return false;

            const pieceColor = getPieceColor(piece);
            const targetPiece = board[toRow][toCol];
            
            // ê°™ì€ ìƒ‰ ë§ì„ ì¡ì„ ìˆ˜ ì—†ìŒ
            if (targetPiece && getPieceColor(targetPiece) === pieceColor) {
                return false;
            }

            const rowDiff = Math.abs(toRow - fromRow);
            const colDiff = Math.abs(toCol - fromCol);

            // ê° ë§ì˜ ì´ë™ ê·œì¹™
            switch (piece) {
                case 'â™™': // ë°± í°
                    if (fromRow === 6 && toRow === 4 && colDiff === 0 && !board[5][fromCol] && !board[4][fromCol]) return true;
                    if (toRow === fromRow - 1 && colDiff === 0 && !targetPiece) return true;
                    if (toRow === fromRow - 1 && colDiff === 1 && targetPiece) return true;
                    // ì•™íŒŒìƒ
                    if (toRow === fromRow - 1 && colDiff === 1 && !targetPiece && 
                        enPassantTarget && enPassantTarget[0] === toRow && enPassantTarget[1] === toCol) return true;
                    return false;
                
                case 'â™Ÿ': // í‘ í°
                    if (fromRow === 1 && toRow === 3 && colDiff === 0 && !board[2][fromCol] && !board[3][fromCol]) return true;
                    if (toRow === fromRow + 1 && colDiff === 0 && !targetPiece) return true;
                    if (toRow === fromRow + 1 && colDiff === 1 && targetPiece) return true;
                    // ì•™íŒŒìƒ
                    if (toRow === fromRow + 1 && colDiff === 1 && !targetPiece && 
                        enPassantTarget && enPassantTarget[0] === toRow && enPassantTarget[1] === toCol) return true;
                    return false;

                case 'â™–': case 'â™œ': // ë£©
                    if (rowDiff === 0 || colDiff === 0) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'â™—': case 'â™': // ë¹„ìˆ
                    if (rowDiff === colDiff) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'â™•': case 'â™›': // í€¸
                    if (rowDiff === 0 || colDiff === 0 || rowDiff === colDiff) {
                        return isPathClear(fromRow, fromCol, toRow, toCol);
                    }
                    return false;

                case 'â™˜': case 'â™': // ë‚˜ì´íŠ¸
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);

                case 'â™”': case 'â™š': // í‚¹
                    return rowDiff <= 1 && colDiff <= 1;
            }
            return false;
        }

        // ê²½ë¡œê°€ ë¹„ì–´ìˆëŠ”ì§€ í™•ì¸
        function isPathClear(fromRow, fromCol, toRow, toCol) {
            const rowStep = toRow > fromRow ? 1 : toRow < fromRow ? -1 : 0;
            const colStep = toCol > fromCol ? 1 : toCol < fromCol ? -1 : 0;
            
            let currentRow = fromRow + rowStep;
            let currentCol = fromCol + colStep;
            
            while (currentRow !== toRow || currentCol !== toCol) {
                if (board[currentRow][currentCol]) return false;
                currentRow += rowStep;
                currentCol += colStep;
            }
            return true;
        }

        // ì‚¬ê°í˜• í´ë¦­ ì²˜ë¦¬
        function handleSquareClick(row, col) {
            if (isGameOver || currentPlayer !== 'white' || pendingPromotion) return;

            const clickedPiece = board[row][col];
            
            if (selectedSquare) {
                const [selectedRow, selectedCol] = selectedSquare;
                
                if (row === selectedRow && col === selectedCol) {
                    // ê°™ì€ ì‚¬ê°í˜• í´ë¦­ - ì„ íƒ í•´ì œ
                    selectedSquare = null;
                    clearHighlights();
                } else if (isValidMove(selectedRow, selectedCol, row, col) && 
                          wouldResolveCheck(selectedRow, selectedCol, row, col, 'white')) {
                    // ìœ íš¨í•œ ì´ë™ì´ê³  ì²´í¬ë¥¼ í•´ê²°í•˜ëŠ” ì´ë™
                    makeMove(selectedRow, selectedCol, row, col);
                    selectedSquare = null;
                    clearHighlights();
                    
                    if (!isGameOver && !pendingPromotion) {
                        setTimeout(() => {
                            aiMove();
                        }, 500);
                    }
                } else {
                    // ìƒˆë¡œìš´ ë§ ì„ íƒ
                    if (clickedPiece && getPieceColor(clickedPiece) === 'white') {
                        selectedSquare = [row, col];
                        highlightSquare(row, col);
                        showPossibleMoves(row, col);
                    } else {
                        selectedSquare = null;
                        clearHighlights();
                    }
                }
            } else {
                // ìƒˆë¡œìš´ ì„ íƒ
                if (clickedPiece && getPieceColor(clickedPiece) === 'white') {
                    selectedSquare = [row, col];
                    highlightSquare(row, col);
                    showPossibleMoves(row, col);
                }
            }
        }

        // ì´ë™ ì‹¤í–‰
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            let isEnPassant = false;
            
            // ì•™íŒŒìƒ ì²˜ë¦¬
            if ((piece === 'â™™' || piece === 'â™Ÿ') && !capturedPiece && Math.abs(toCol - fromCol) === 1) {
                if (enPassantTarget && enPassantTarget[0] === toRow && enPassantTarget[1] === toCol) {
                    isEnPassant = true;
                    const capturedRow = piece === 'â™™' ? toRow + 1 : toRow - 1;
                    board[capturedRow][toCol] = null; // ì•™íŒŒìƒìœ¼ë¡œ ì¡íŒ í° ì œê±°
                }
            }
            
            // ì†Œë¦¬ ì¬ìƒ
            if (capturedPiece || isEnPassant) {
                playCaptureSound();
            } else {
                playMoveSound();
            }
            
            // íˆìŠ¤í† ë¦¬ì— ì €ì¥
            gameHistory.push({
                from: [fromRow, fromCol],
                to: [toRow, toCol],
                piece: piece,
                captured: capturedPiece,
                player: currentPlayer,
                enPassantTarget: enPassantTarget,
                isEnPassant: isEnPassant
            });
            
            // ì•™íŒŒìƒ íƒ€ê²Ÿ ì—…ë°ì´íŠ¸
            enPassantTarget = null;
            if ((piece === 'â™™' && fromRow === 6 && toRow === 4) || 
                (piece === 'â™Ÿ' && fromRow === 1 && toRow === 3)) {
                enPassantTarget = [piece === 'â™™' ? 5 : 2, fromCol];
            }
            
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            
            // í”„ë¡œëª¨ì…˜ ì²´í¬
            if ((piece === 'â™™' && toRow === 0) || (piece === 'â™Ÿ' && toRow === 7)) {
                if (currentPlayer === 'white') {
                    // í”Œë ˆì´ì–´ í”„ë¡œëª¨ì…˜
                    pendingPromotion = { row: toRow, col: toCol, color: 'white' };
                    document.getElementById('promotionModal').style.display = 'flex';
                    return; // í”„ë¡œëª¨ì…˜ ì„ íƒê¹Œì§€ ëŒ€ê¸°
                } else {
                    // AI í”„ë¡œëª¨ì…˜ (ìë™ìœ¼ë¡œ í€¸ ì„ íƒ)
                    board[toRow][toCol] = 'â™›';
                }
            }
            
            // í‚¹ì´ ì¡í˜”ëŠ”ì§€ í™•ì¸
            if (capturedPiece === 'â™š' || capturedPiece === 'â™”') {
                isGameOver = true;
                const winner = currentPlayer === 'white' ? 'ë°±' : 'í‘';
                document.getElementById('gameStatus').textContent = `ê²Œì„ ì¢…ë£Œ! ${winner}ì˜ ìŠ¹ë¦¬!`;
                renderBoard();
                playCheckmateSound();
                return;
            }
            
            // í”Œë ˆì´ì–´ ë³€ê²½
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            // ë³´ë“œ ë¨¼ì € ë Œë”ë§
            renderBoard();
            updateGameStatus();
            
            // ì²´í¬ë©”ì´íŠ¸ í™•ì¸ (ë³´ë“œ ë Œë”ë§ í›„)
            setTimeout(() => {
                if (isCheckmate(currentPlayer)) {
                    isGameOver = true;
                    const winner = currentPlayer === 'white' ? 'í‘' : 'ë°±';
                    document.getElementById('gameStatus').textContent = `ì²´í¬ë©”ì´íŠ¸! ${winner}ì˜ ìŠ¹ë¦¬!`;
                    playCheckmateSound();
                }
            }, 100);
        }

        // AI ì´ë™
        function aiMove() {
            if (isGameOver || currentPlayer !== 'black') return;
            
            document.getElementById('thinking').style.display = 'block';
            
            setTimeout(() => {
                const possibleMoves = getAllPossibleMoves('black');
                
                if (possibleMoves.length === 0) {
                    isGameOver = true;
                    document.getElementById('gameStatus').textContent = 'ê²Œì„ ì¢…ë£Œ! ë°±ì˜ ìŠ¹ë¦¬!';
                    document.getElementById('thinking').style.display = 'none';
                    renderBoard();
                    playCheckmateSound();
                    return;
                }
                
                // ë‚œì´ë„ë³„ AI ë¡œì§
                let bestMove = null;
                let bestScore = -1000;
                
                // ë‚œì´ë„ 6: ì ˆëŒ€ ì´ê¸¸ ìˆ˜ ì—†ëŠ” AI (ë¯¸ë‹ˆë§¥ìŠ¤ ì•Œê³ ë¦¬ì¦˜ ì‹œë®¬ë ˆì´ì…˜)
                if (aiDifficulty === 6) {
                    bestMove = getBestMoveAdvanced(possibleMoves);
                } else {
                    for (const move of possibleMoves) {
                        let score = 0;
                        
                        // ë‚œì´ë„ 1: ì™„ì „ ëœë¤
                        if (aiDifficulty === 1) {
                            score = Math.random() * 100;
                        } else {
                            // ê¸°ë³¸ ëœë¤ ìš”ì†Œ (ë‚œì´ë„ê°€ ë†’ì„ìˆ˜ë¡ ì¤„ì–´ë“¦)
                            score = Math.random() * (60 - aiDifficulty * 10);
                            
                            // ìƒëŒ€ ë§ì„ ì¡ì„ ìˆ˜ ìˆìœ¼ë©´ ë†’ì€ ì ìˆ˜
                            if (board[move.to[0]][move.to[1]]) {
                                const capturedPiece = board[move.to[0]][move.to[1]];
                                let captureScore = 0;
                                if (capturedPiece === 'â™”') captureScore = 1000; // í‚¹
                                else if (capturedPiece === 'â™•') captureScore = 90; // í€¸
                                else if (capturedPiece === 'â™–') captureScore = 50; // ë£©
                                else if (capturedPiece === 'â™—' || capturedPiece === 'â™˜') captureScore = 30; // ë¹„ìˆ, ë‚˜ì´íŠ¸
                                else if (capturedPiece === 'â™™') captureScore = 10; // í°
                                
                                score += captureScore * (aiDifficulty / 5);
                            }
                            
                            // ë‚œì´ë„ 3 ì´ìƒ: ì¤‘ì•™ ì œì–´ ê³ ë ¤
                            if (aiDifficulty >= 3) {
                                const centerDistance = Math.abs(3.5 - move.to[0]) + Math.abs(3.5 - move.to[1]);
                                score += (7 - centerDistance) * aiDifficulty;
                            }
                            
                            // ë‚œì´ë„ 4 ì´ìƒ: ë§ì˜ ì•ˆì „ì„± ê³ ë ¤
                            if (aiDifficulty >= 4) {
                                // ê³µê²©ë°›ì„ ìˆ˜ ìˆëŠ” ìœ„ì¹˜ì¸ì§€ í™•ì¸
                                let isUnderAttack = false;
                                for (let row = 0; row < 8; row++) {
                                    for (let col = 0; col < 8; col++) {
                                        const piece = board[row][col];
                                        if (piece && getPieceColor(piece) === 'white') {
                                            if (isValidMove(row, col, move.to[0], move.to[1])) {
                                                isUnderAttack = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (isUnderAttack) break;
                                }
                                if (isUnderAttack) score -= 20;
                            }
                            
                            // ë‚œì´ë„ 5: ë” ê¹Šì€ ì „ëµì  ì‚¬ê³ 
                            if (aiDifficulty === 5) {
                                // í‚¹ ì•ˆì „ì„±
                                const kingPos = findKing('black');
                                if (kingPos) {
                                    const kingDistance = Math.abs(kingPos[0] - move.to[0]) + Math.abs(kingPos[1] - move.to[1]);
                                    if (kingDistance < 3) score += 5; // í‚¹ ê·¼ì²˜ì—ì„œ ë°©ì–´
                                }
                                
                                // í° êµ¬ì¡° ê³ ë ¤
                                if (move.piece === 'â™Ÿ') {
                                    if (move.to[0] > 4) score += 15; // ì „ì§„í•œ í°ì— ë³´ë„ˆìŠ¤
                                }
                            }
                        }
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = move;
                        }
                    }
                }
                
                if (bestMove) {
                    makeMove(bestMove.from[0], bestMove.from[1], bestMove.to[0], bestMove.to[1]);
                }
                
                document.getElementById('thinking').style.display = 'none';
            }, 1000);
        }

        // ëª¨ë“  ê°€ëŠ¥í•œ ì´ë™ ê°€ì ¸ì˜¤ê¸°
        function getAllPossibleMoves(color) {
            const moves = [];
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && getPieceColor(piece) === color) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(row, col, toRow, toCol) && 
                                    wouldResolveCheck(row, col, toRow, toCol, color)) {
                                    moves.push({
                                        from: [row, col],
                                        to: [toRow, toCol],
                                        piece: piece
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            return moves;
        }

        // í•˜ì´ë¼ì´íŠ¸ í‘œì‹œ
        function highlightSquare(row, col) {
            clearHighlights();
            const square = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            square.classList.add('selected');
        }

        // ì´ë™ ê°€ëŠ¥í•œ ì¹¸ í‘œì‹œ
        function showPossibleMoves(row, col) {
            const pieceColor = getPieceColor(board[row][col]);
            for (let toRow = 0; toRow < 8; toRow++) {
                for (let toCol = 0; toCol < 8; toCol++) {
                    if (isValidMove(row, col, toRow, toCol) && 
                        wouldResolveCheck(row, col, toRow, toCol, pieceColor)) {
                        const square = document.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
                        square.classList.add('possible-move');
                    }
                }
            }
        }

        // í•˜ì´ë¼ì´íŠ¸ ì œê±°
        function clearHighlights() {
            document.querySelectorAll('.square').forEach(square => {
                square.classList.remove('selected', 'possible-move', 'last-move');
            });
        }

        // í‚¹ ìœ„ì¹˜ ì°¾ê¸°
        function findKing(color) {
            const kingPiece = color === 'white' ? 'â™”' : 'â™š';
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if (board[row][col] === kingPiece) {
                        return [row, col];
                    }
                }
            }
            return null;
        }

        // ë§ì˜ ê°€ì¹˜ ê³„ì‚°
        function getPieceValue(piece) {
            if (!piece) return 0;
            switch (piece) {
                case 'â™”': case 'â™š': return 1000;
                case 'â™•': case 'â™›': return 90;
                case 'â™–': case 'â™œ': return 50;
                case 'â™—': case 'â™': case 'â™˜': case 'â™': return 30;
                case 'â™™': case 'â™Ÿ': return 10;
                default: return 0;
            }
        }

        // ë³´ë“œ í‰ê°€ í•¨ìˆ˜ (ë‚œì´ë„ 6ìš©)
        function evaluateBoard() {
            let score = 0;
            
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        const value = getPieceValue(piece);
                        const color = getPieceColor(piece);
                        
                        if (color === 'black') {
                            score += value;
                            // ìœ„ì¹˜ ë³´ë„ˆìŠ¤
                            if (piece === 'â™Ÿ' && row > 4) score += 5; // ì „ì§„í•œ í°
                            if ((piece === 'â™' || piece === 'â™') && row > 2 && row < 6 && col > 1 && col < 6) score += 5; // ì¤‘ì•™ ì œì–´
                        } else {
                            score -= value;
                            // ìƒëŒ€ë°© ìœ„ì¹˜ í˜ë„í‹°
                            if (piece === 'â™™' && row < 4) score -= 5;
                        }
                    }
                }
            }
            
            // í‚¹ ì•ˆì „ì„± í‰ê°€
            const blackKing = findKing('black');
            const whiteKing = findKing('white');
            
            if (blackKing) {
                // í‚¹ ì£¼ë³€ ì•ˆì „ì„± ì²´í¬
                let safeSquares = 0;
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        const newRow = blackKing[0] + dr;
                        const newCol = blackKing[1] + dc;
                        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                            if (!isSquareUnderAttack(newRow, newCol, 'white')) {
                                safeSquares++;
                            }
                        }
                    }
                }
                score += safeSquares * 2;
            }
            
            return score;
        }

        // íŠ¹ì • ìœ„ì¹˜ê°€ ê³µê²©ë°›ê³  ìˆëŠ”ì§€ í™•ì¸
        function isSquareUnderAttack(row, col, attackerColor) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && getPieceColor(piece) === attackerColor) {
                        if (isValidMove(r, c, row, col)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // ì²´í¬ ìƒíƒœ í™•ì¸
        function checkForCheck() {
            const whiteKing = findKing('white');
            const blackKing = findKing('black');
            
            isInCheck.white = whiteKing ? isSquareUnderAttack(whiteKing[0], whiteKing[1], 'black') : false;
            isInCheck.black = blackKing ? isSquareUnderAttack(blackKing[0], blackKing[1], 'white') : false;
        }

        // ì´ë™ì´ ì²´í¬ë¥¼ í•´ê²°í•˜ëŠ”ì§€ í™•ì¸
        function wouldResolveCheck(fromRow, fromCol, toRow, toCol, color) {
            const piece = board[fromRow][fromCol];
            const captured = board[toRow][toCol];
            
            // ì„ì‹œë¡œ ì´ë™ ì‹¤í–‰
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = null;
            
            const kingPos = findKing(color);
            const stillInCheck = kingPos ? isSquareUnderAttack(kingPos[0], kingPos[1], color === 'white' ? 'black' : 'white') : false;
            
            // ì´ë™ ë³µì›
            board[fromRow][fromCol] = piece;
            board[toRow][toCol] = captured;
            
            return !stillInCheck;
        }

        // ì²´í¬ë©”ì´íŠ¸ í™•ì¸
        function isCheckmate(color) {
            checkForCheck();
            
            // ì²´í¬ ìƒíƒœê°€ ì•„ë‹ˆë©´ ì²´í¬ë©”ì´íŠ¸ê°€ ì•„ë‹˜
            if (!isInCheck[color]) return false;
            
            // ëª¨ë“  ê°€ëŠ¥í•œ ì´ë™ì„ í™•ì¸
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece && getPieceColor(piece) === color) {
                        for (let toRow = 0; toRow < 8; toRow++) {
                            for (let toCol = 0; toCol < 8; toCol++) {
                                if (isValidMove(row, col, toRow, toCol)) {
                                    if (wouldResolveCheck(row, col, toRow, toCol, color)) {
                                        return false; // ì²´í¬ë¥¼ í•´ê²°í•  ìˆ˜ ìˆëŠ” ì´ë™ì´ ìˆìŒ
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return true; // ì²´í¬ë¥¼ í•´ê²°í•  ì´ë™ì´ ì—†ìŒ = ì²´í¬ë©”ì´íŠ¸
        }

        // í”„ë¡œëª¨ì…˜ ì„ íƒ
        function selectPromotion(pieceType) {
            if (!pendingPromotion) return;
            
            const pieces = {
                queen: pendingPromotion.color === 'white' ? 'â™•' : 'â™›',
                rook: pendingPromotion.color === 'white' ? 'â™–' : 'â™œ',
                bishop: pendingPromotion.color === 'white' ? 'â™—' : 'â™',
                knight: pendingPromotion.color === 'white' ? 'â™˜' : 'â™'
            };
            
            board[pendingPromotion.row][pendingPromotion.col] = pieces[pieceType];
            
            document.getElementById('promotionModal').style.display = 'none';
            pendingPromotion = null;
            
            // í”Œë ˆì´ì–´ ë³€ê²½
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            // ë³´ë“œ ë¨¼ì € ë Œë”ë§
            renderBoard();
            updateGameStatus();
            
            // ì²´í¬ë©”ì´íŠ¸ í™•ì¸ (ë³´ë“œ ë Œë”ë§ í›„)
            setTimeout(() => {
                if (isCheckmate(currentPlayer)) {
                    isGameOver = true;
                    const winner = currentPlayer === 'white' ? 'í‘' : 'ë°±';
                    document.getElementById('gameStatus').textContent = `ì²´í¬ë©”ì´íŠ¸! ${winner}ì˜ ìŠ¹ë¦¬!`;
                    playCheckmateSound();
                    return;
                }
                
                // AI ì°¨ë¡€ë¼ë©´ AI ì´ë™
                if (currentPlayer === 'black' && !isGameOver) {
                    setTimeout(() => {
                        aiMove();
                    }, 500);
                }
            }, 100);
        }

        // ê³ ê¸‰ AI ì´ë™ ì„ íƒ (ë‚œì´ë„ 6)
        function getBestMoveAdvanced(possibleMoves) {
            let bestMove = null;
            let bestScore = -10000;
            
            for (const move of possibleMoves) {
                // ì´ë™ ì‹œë®¬ë ˆì´ì…˜
                const originalPiece = board[move.to[0]][move.to[1]];
                board[move.to[0]][move.to[1]] = board[move.from[0]][move.from[1]];
                board[move.from[0]][move.from[1]] = null;
                
                // ìƒëŒ€ë°©ì˜ ìµœì„  ì‘ìˆ˜ ê³ ë ¤ (1ìˆ˜ ì• ì½ê¸°)
                let worstResponse = 10000;
                const opponentMoves = getAllPossibleMoves('white');
                
                for (const opMove of opponentMoves.slice(0, 10)) { // ì„±ëŠ¥ì„ ìœ„í•´ ìƒìœ„ 10ê°œë§Œ ì²´í¬
                    const opOriginal = board[opMove.to[0]][opMove.to[1]];
                    board[opMove.to[0]][opMove.to[1]] = board[opMove.from[0]][opMove.from[1]];
                    board[opMove.from[0]][opMove.from[1]] = null;
                    
                    const score = evaluateBoard();
                    if (score < worstResponse) {
                        worstResponse = score;
                    }
                    
                    // ë³µì›
                    board[opMove.from[0]][opMove.from[1]] = board[opMove.to[0]][opMove.to[1]];
                    board[opMove.to[0]][opMove.to[1]] = opOriginal;
                }
                
                // ì¦‰ì‹œ ìŠ¹ë¦¬ ì²´í¬
                if (originalPiece === 'â™”') {
                    worstResponse = 10000; // í‚¹ì„ ì¡ìœ¼ë©´ ì¦‰ì‹œ ìŠ¹ë¦¬
                }
                
                // ì²´í¬ë©”ì´íŠ¸ ìœ„í˜‘ ì²´í¬
                const whiteKing = findKing('white');
                if (whiteKing && isValidMove(move.from[0], move.from[1], whiteKing[0], whiteKing[1])) {
                    worstResponse += 500; // ì²´í¬ ë³´ë„ˆìŠ¤
                }
                
                if (worstResponse > bestScore) {
                    bestScore = worstResponse;
                    bestMove = move;
                }
                
                // ë³µì›
                board[move.from[0]][move.from[1]] = board[move.to[0]][move.to[1]];
                board[move.to[0]][move.to[1]] = originalPiece;
            }
            
            return bestMove || possibleMoves[0];
        }

        // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateGameStatus() {
            if (isGameOver) return;
            
            const statusText = currentPlayer === 'white' ? 'ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤ (ë°±)' : 'AIì˜ ì°¨ë¡€ì…ë‹ˆë‹¤ (í‘)';
            document.getElementById('gameStatus').textContent = statusText;
        }

        // ìƒˆ ê²Œì„
        function newGame() {
            initializeBoard();
            selectedSquare = null;
            currentPlayer = 'white';
            gameHistory = [];
            isGameOver = false;
            enPassantTarget = null;
            pendingPromotion = null;
            isInCheck = { white: false, black: false };
            clearHighlights();
            renderBoard();
            updateGameStatus();
            document.getElementById('thinking').style.display = 'none';
            document.getElementById('promotionModal').style.display = 'none';
        }

        // ë¬´ë¥´ê¸°
        function undoMove() {
            if (gameHistory.length < 2) return; // AIì™€ í”Œë ˆì´ì–´ ë‘˜ ë‹¤ ë¬´ë¥´ê¸°
            
            // í”Œë ˆì´ì–´ ì´ë™ ë¬´ë¥´ê¸°
            const playerMove = gameHistory.pop();
            board[playerMove.from[0]][playerMove.from[1]] = playerMove.piece;
            board[playerMove.to[0]][playerMove.to[1]] = playerMove.captured;
            
            // ì•™íŒŒìƒ ë³µì›
            if (playerMove.isEnPassant) {
                const capturedRow = playerMove.piece === 'â™™' ? playerMove.to[0] + 1 : playerMove.to[0] - 1;
                board[capturedRow][playerMove.to[1]] = playerMove.piece === 'â™™' ? 'â™Ÿ' : 'â™™';
            }
            
            // AI ì´ë™ ë¬´ë¥´ê¸°
            if (gameHistory.length > 0) {
                const aiMove = gameHistory.pop();
                board[aiMove.from[0]][aiMove.from[1]] = aiMove.piece;
                board[aiMove.to[0]][aiMove.to[1]] = aiMove.captured;
                
                // AI ì•™íŒŒìƒ ë³µì›
                if (aiMove.isEnPassant) {
                    const capturedRow = aiMove.piece === 'â™™' ? aiMove.to[0] + 1 : aiMove.to[0] - 1;
                    board[capturedRow][aiMove.to[1]] = aiMove.piece === 'â™™' ? 'â™Ÿ' : 'â™™';
                }
                
                enPassantTarget = aiMove.enPassantTarget;
            }
            
            currentPlayer = 'white';
            isGameOver = false;
            selectedSquare = null;
            pendingPromotion = null;
            clearHighlights();
            renderBoard();
            updateGameStatus();
            document.getElementById('thinking').style.display = 'none';
            document.getElementById('promotionModal').style.display = 'none';
        }

        // ë‚œì´ë„ ì„¤ì •
        function setDifficulty(level) {
            aiDifficulty = level;
            
            // ëª¨ë“  ë‚œì´ë„ ë²„íŠ¼ì—ì„œ active í´ë˜ìŠ¤ ì œê±°
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // ì„ íƒëœ ë‚œì´ë„ ë²„íŠ¼ì— active í´ë˜ìŠ¤ ì¶”ê°€
            event.target.classList.add('active');
        }

        // ê²Œì„ ì´ˆê¸°í™”
        initializeBoard();
        renderBoard();
        updateGameStatus();
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'982308ba934a8b6a',t:'MTc1ODM4OTI1Mi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
